@startuml
left to right direction
skinparam classAttributeIconSize 0
skinparam componentStyle rectangle
title YerbEngine - Sparse Set ECS Architecture

' Core
package "Core" {
  class GameEngine {
    - m_fontManager: std::unique_ptr<FontManager>
    - m_textureManager: std::unique_ptr<TextureManager>
    - m_audioManager: std::unique_ptr<AudioManager>
    - m_audioSampleQueue: std::unique_ptr<AudioSampleQueue>
    - m_videoManager: std::unique_ptr<VideoManager>
    - m_config: ConfigAdapter*
    - m_currentScene: shared_ptr<Scene>
    - m_running: bool
    + GameEngine(configPath: string)
    + LoadScene(name: string, scene: shared_ptr<Scene>) : void
    + GetConfig() : ConfigAdapter&
    + Run() : void
    + UpdateLoop(delta: float) : void
  }

  abstract class Scene {
    - m_gameEngine: GameEngine*
    + Scene(engine: GameEngine*)
    + virtual update(delta: float) : void
    + virtual sRender() : void
    + virtual sDoAction(action: Action&) : void
    + virtual sAudio() : void
    + virtual onEnd() : void
    + virtual onSceneWindowResize(w: int, h: int) : void
  }
}

package "Managers" {
  package "Asset Managers" {
    class FontManager {
      - m_fonts: map<string, Font>
      + loadFont(path: string, size: int) : FontID
      + getFont(id: FontID) : Font
    }

    class TextureManager {
      - m_textures: map<string, Texture>
      + loadTexture(path: string) : TextureID
      + getTexture(id: TextureID) : Texture
    }

    class AudioSampleQueue {
      - queue: deque<AudioSample>
      + queueSample(sampleId: AudioSampleID, volume: float) : void
      + update() : void
    }
  }

  package "System Managers" {
    class AudioManager {
      - m_tracks: map<AudioTrack, Track>
      + playTrack(track: AudioTrack, loops: int) : void
      + muteTracks() : void
      + getCurrentAudioTrack() : AudioTrack
    }

    class VideoManager {
      - renderer: SDL_Renderer*
      + getRenderer() : SDL_Renderer*
      + getWindowSize() : Vec2
    }
  }
}

' Configuration subsystem
package "Configuration" {
  class ConfigStore {
    - m_values: map<string, string>
    + get(key: string) : string
    + set(key: string, value: string) : void
  }

  class JsonConfigProvider {
    + loadFromFile(path: string) : ConfigStore
  }

  class ConfigAdapter {
    - store: ConfigStore*
    + getInt(key: string, def: int) : int
    + getFloat(key: string, def: float) : float
    + getString(key: string, def: string) : string
  }
}

' Entity-Component System with Sparse Sets
package "ECS" {
  class EntityManager {
    - m_nextEntityId: size_t
    - m_livingEntities: vector<size_t>
    - m_entityTags: unordered_map<size_t, EntityTags>
    - m_taggedEntities: unordered_map<EntityTags, vector<size_t>>
    - m_componentArrays: unordered_map<type_index, unique_ptr<IComponentArray>>
    + createEntity(tag: EntityTags) : size_t
    + destroyEntity(entityId: size_t) : void
    + addComponent<T>(entityId: size_t, component: T) : void
    + removeComponent<T>(entityId: size_t) : void
    + getComponent<T>(entityId: size_t) : T&
    + hasComponent<T>(entityId: size_t) : bool
    + getEntitiesByTag(tag: EntityTags) : vector<size_t>&
    + update() : void
  }

  interface IComponentArray {
    + {abstract} entityDestroyed(entityId: size_t) : void
  }

  class "SparseSet<T>" {
    - m_sparse: vector<size_t>
    - m_dense: vector<size_t>
    - m_components: vector<T>
    - m_size: size_t
    + insert(entityId: size_t, component: T) : void
    + remove(entityId: size_t) : void
    + get(entityId: size_t) : T&
    + contains(entityId: size_t) : bool
    + size() : size_t
    + data() : T*
    + entities() : size_t*
    + entityDestroyed(entityId: size_t) : void
  }

  class CTransform {
    + topLeftCornerPos: Vec2
    + velocity: Vec2
    + CTransform(position: Vec2, velocity: Vec2)
  }

  class CShape {
    + rect: SDL_Rect
    + color: SDL_Color
    + CShape(height: float, width: float, color: SDL_Color)
  }

  class CInput {
    + forward: bool
    + backward: bool
    + left: bool
    + right: bool
    + CInput()
  }

  class CLifespan {
    + birthTime: Uint64
    + lifespan: Uint64
    + CLifespan()
    + CLifespan(lifespan: Uint64)
  }

  class CEffects {
    + effects: vector<Effect>
    + addEffect(effect: Effect) : void
    + getEffects() : vector<Effect> const&
    + removeEffect(type: EffectTypes) : void
    + hasEffect(type: EffectTypes) : bool
    + clearEffects() : void
  }

  class CBounceTracker {
    + m_bounces: int
    + addBounce() : void
    + getBounces() : int
  }

  class CSprite {
    + m_texture: SDL_Texture*
    + CSprite(texture: SDL_Texture*)
    + getTexture() : SDL_Texture*
  }
}

' Relationships
GameEngine --> FontManager : owns
GameEngine --> TextureManager : owns
GameEngine --> AudioManager : owns
GameEngine --> AudioSampleQueue : owns
GameEngine --> VideoManager : owns
GameEngine --> ConfigAdapter : uses
GameEngine --> Scene : manages

Scene --> EntityManager : uses
Scene --> TextureManager : uses
Scene --> AudioManager : uses

ConfigAdapter --> ConfigStore : backs
JsonConfigProvider --> ConfigStore : loads

EntityManager --> IComponentArray : manages
"SparseSet<T>" ..|> IComponentArray : implements
EntityManager --> "SparseSet<T>" : creates/stores

"SparseSet<T>" ..> CTransform : stores
"SparseSet<T>" ..> CShape : stores
"SparseSet<T>" ..> CInput : stores
"SparseSet<T>" ..> CLifespan : stores
"SparseSet<T>" ..> CEffects : stores
"SparseSet<T>" ..> CBounceTracker : stores
"SparseSet<T>" ..> CSprite : stores

note left of EntityManager
  Entities are now just IDs (size_t)
  Components stored in separate sparse sets
  O(1) add/remove/lookup per component
end note

note right of "SparseSet<T>"
  Sparse array: entityId -> dense index
  Dense arrays: contiguous component storage
  Cache-friendly iteration for systems
end note

note bottom of CShape
  Components are now POD (no SDL_Renderer*)
  Renderer accessed through systems instead
end note

@enduml